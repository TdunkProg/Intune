#########################
#    PowerShell Help    #
#########################

<#
.SYNOPSIS
    This script is designed to deploy printers to Windows 10/11 workstations deployed and triggered by Intune.
.DESCRIPTION
    Written by Jean-Pierre Simonis 
    Modified by M365 Education Technology

    #########################
    #      Change Log       #
    #########################
    
    # 23/11/2017 1.1
    # Features
    # - Add support for MSI install keys so that script deployment via Intune reports as successful
    #
    # 10/11/2017 v1.0 - Initial Release
    #  Features
    # - Error trapping and logging 
    # - Unzip Printer Driver package
    # - Install Local Printer Queue
   
.NOTES

    #########################
    #         Notes         #
    #########################

    # This script is designed to be packaged as an exe and pushed out via Intune 
    #
    #
    # This script requires the following permissions
    # 
    #  - Elevated PowerShell Session first time only to create custom eventlog type
    #  - Permission to update install the printer (Assumed it will run in Intune installation context)
    #  - Your endpoint protection may need this package to be added as an exception as it might detect and block it as this script extracts itself and launch a script in an administrative context

    # Installation
    # 1. Ensure script is run against Windows 10 devices with at least PowerShell V5.1
    # 2. Create printer driver zip file
    # 3. Configure variables in PowerShell Script to desired printer configuration supply name of driver zip file
    # 4. Create batch file to launch PowerShell script (Refer below instructions for contents of batch file) 
    # 5. Create Self-extracting executable (I used WinRAR) 
    #       a.	Configure it to extract to temporary directory
    #       b.	Configure post launch a command (deploy.bat)
    #       c.	Configure Icon, Overwrite (Replace) and Title settings
    #       d.	Configure for silent extraction (hidden dialogs)
    #       e.  Ensure deploy.bat, Deploy-Printer.ps1, PrinterDriver.zip are added to archive
    # 6. Use MSI Wrapper to convert the EXE to MSI
    #       a. download from http://www.exemsi.com
    #       b. Configure MSI Settings
    #              Application ID (ensure this value is the same as defined in script configuration)
    #              Deploy Printer Package 1
    #              Upgrade Code (This can generated by MSI Wrapper)
    #              {E6454CC0-00B2-4134-9D28-9089E5628C4B}
    #              Product Name
    #              Deploy Printer Package
    #              Version
    #              1.0.0.0
    #              Icon
    #              PowerShell.ico (I downloaded and used a powershell logo in ico format)
    #              Comments
    #              PowerShell Script to Deploy Campus Side Printer
    #
    # 7. (Optional) Use ORCA to modify MSI tables to update product name to remove (wrapped by MSI Wrapper in title or buy the product)
    #        a. download from https://msdn.microsoft.com/en-us/library/windows/desktop/aa370557(v=vs.85).aspx
    # 8. Configure Intune to deploy LOB Windows Application
    # 9. Enjoy Customer Success 😊

    # Contents of deploy.bat

    @echo off
    REM Written by Jean-Pierre Simonis, Delivery Quality Assurance, www.deliveryqa.com.au
 
    @echo Launching Printer Deployment PowerShell Script
    powershell.exe -executionpolicy unrestricted -file .\Deploy-Printer.ps1

    # End of Script

.LINK
#>

#########################
#   Pre-req Functions   #
#########################

#Function to log to file and write output to host
#Logging can be configured through the logging section in the Configuration area of this script.

Function LogWrite
{
    Param (
    [Parameter(Mandatory=$True)]
    [string]$Logstring,
    [Parameter(Mandatory=$True)]
    [string]$type,
    [Parameter(Mandatory=$False)]
    [string]$v    
    )
    #Check if Logging is wanted
    if ($global:logging -eq $true) {
        
        #Determine Log Entry Type        
        Switch ($type){
            start { 
                $logType = "[Start]"
                $elogtype = "Information"
                $logColour = "Green"
            }
            i { 
                $logType = "[Info]"
                $elogtype = "Information"
                $logColour = "White"
            }
            w { 
                $logType = "[Warning]"
                $elogtype = "Warning"
                $logColour = "Yellow"
            }
            e { 
                $logType = "[Error]"
                $elogtype = "Error"
                $logColour = "Red"
            }
            end { 
                $logType = "[End]"
                $elogtype = "Information"
                $logColour = "Green"
            }
        }
        #Log Time Date for each log entry
        if ($global:logTimeDate -eq $true) {
            $TimeStamp = Get-Date -Format "yyyy-MM-dd-HH:mm"
            $TimeStamp = "[$TimeStamp]"
        } else {
            $TimeStamp = $Null
        }
        #Create Eventlog Source
        if ($global:logtoEventlog -eq $true) {
            #Check if log source exists
            $checkLogSourceExists = [System.Diagnostics.EventLog]::SourceExists("$global:eventlogSource")
            if ($checkLogSourceExists -eq $False) {
                New-EventLog -LogName Application -Source $global:eventlogSource -ErrorAction SilentlyContinue
            }
        }

        #Check if Verbose logging enabled and of log entry is marked as verbose
        if ($global:verboselog -eq $true -and $v -eq $true){
            #Check if Log Entry is marked as verbose       
                if ($global:logtoFile -eq $true) {Add-Content $Logfile -value "$TimeStamp[Verbose]$logType $logstring" -ErrorAction Stop}
                if ($global:logtoEventlog -eq $true) {Write-EventLog –LogName Application –Source global:eventlogSource –EntryType $elogtype –EventID 1 –Message $logstring -ErrorAction Stop}
                Write-Host "[Verbose]$logType $logstring" -ForegroundColor $logColour

        } else {
            #Check if log is verbose if it is dont log it otherwise log a standard entry
            if ($v -eq $true) {        
                #Do Nothing
            } else {
                #Write Standard Log Entry
                if ($global:logtoFile -eq $true) {Add-Content $Logfile -value "$TimeStamp$logType $logstring" -ErrorAction Stop}
                if ($global:logtoEventlog -eq $true) {Write-EventLog –LogName Application –Source $global:eventlogSource –EntryType $elogtype –EventID 1 –Message $logstring -ErrorAction Stop}
            }

            #Write Standard Log Entries to Screen if verbose logging is enabled
            if ($global:verboselog -eq $true){
                Write-Host "$logType $logstring" -ForegroundColor $logColour
            }
        }

    }
}

#######################
#     Parameters      #
#######################

# General
    #Current Script Location
    $PSScriptRoot = Split-Path -Parent -Path $MyInvocation.MyCommand.Definition
    #Current Time and Date
    $TimeDate = Get-Date -Format "yyyy-MM-dd-HH:mm:ss"
    #MSI Application ID (required so that Intune knows script package successfully deployed)
    #Note: Ensure when creating MSI that the Application ID is the same one defined in this variable.
    $ApplicationID = "Deploy Printer Package 1"
    #Install Path (Path to unzip driver and script to)
    $InstallPath = "$env:PROGRAMFILES" + "\SomePrinter"
    #Zip File Name (Zipped up Driver)
    $ZipFile = "$PSScriptRoot\PrinterDriver.zip"
    #Driver INF to install
    $PrinterDriverInf = "DriverINFFileName.INF"
    #Path to Inf file for printer driver installation
    $InstallDriverPath = $InstallPath + "\" + $PrinterDriverInf
    #Printer Name (Seen by End User)
    $PrinterName = "End User Printer Display Name"
    #Printer Driver Name (Collect from inside INF file)
    $PrinterDriver = “Printer Driver to Install eg. KONICA MINOLTA C658SeriesPCL"
    #Printer Port Name
    $PrinterPortName = “TCPIP:SomePrinter”
    #Printer IP Address
    $PrinterIPAddress = "0.0.0.0"
    #LPR Queue Name (If Applicable)
    $PrinterLPRQueueName = “Secure”
 
# Logging
    $Logfile = ($PSScriptRoot + "\Logs\" + $TimeDate + "-DeployPrinter.log")
    $global:logging = $true
    $global:verboselog = $false
    $global:logtoEventlog = $true
    $global:logtoFile = $false
    $global:logTimeDate = $true
    $global:eventlogSource = "Deploy-Printer"

    #Start logging and check logfile access
	try 
	{
		LogWrite "$eventlogSource script started - $TimeDate" -type start
	} 
	catch 
	{
        Throw "You don't have write permissions to $logfile, please start an elevated PowerShell prompt or change NTFS permissions"
	}

#######################
#      Functions      #
#######################

function unzip ($file,$ExtractPath) {
    LogWrite "Extracting $file to $ExtractPath" -type i
    expand-archive -Path $file -DestinationPath $ExtractPath -Force
}

#######################
#      Execution      #
#######################

try
{

    LogWrite "Checking $InstallPath exists if not create path" -type i -v $true
    $CheckInstallPath = test-path -path $InstallPath
    If ($CheckInstallPath -ne $true) {
        New-Item -ItemType "Directory" -Path $InstallPath -Force
    }

    #Add registry entries so powershell registers as successfully run MSI for MSI deployment
    New-Item -path HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall -Name $ApplicationID
    New-ItemProperty -path HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\$ApplicationID -Name UninstallString -PropertyType String -Value $ApplicationID

    #Unzip Printer Driver zip to installation path
    LogWrite "Unzip Printer Driver zip to installation path" -type i
    $ExtractDriver = Unzip $ZipFile $InstallPath
       
    #Import Printer Driver into Windows Driver Store
    #Note: the sysnative path below is required so pnputil can be found when deploying via intune for 64bit OSes.
    #if you want to test interactively temporary change the path to system32
    LogWrite "Import Printer Driver:$InstallDriverPath into Windows Driver Store" -type i
    $PNPUtil = $env:windir + "\Sysnative\" + 'pnputil.exe'
    & $PNPUtil /add-driver $InstallDriverPath
    
    #Add Printer Driver so it is available for use to create a printer with
    LogWrite "Add Printer Driver: $PrinterDriver so it is available for use to create a printer with" -type i
    Add-PrinterDriver -Name $PrinterDriver
    
    #Note: do not create both a standard LPR Port and a Standard TCPIP Port Comment out the port that is not required
    
    #Create LPR Port (Uncomment lines below to create a LPR Port)
    #LogWrite "Create LPR Port" -type i
    #Add-PrinterPort -Name $PrinterPortName -LprHostAddress $PrinterIPAddress -LprQueueName $PrinterLPRQueueName
    
    #Create Standard TCPIP Port
    LogWrite "Create Standard TCPIP Port: $PrinterPortName" -type i
    Add-PrinterPort -Name $PrinterPortName -PrinterHostAddress $PrinterIPAddress
    
    #Create Printer
    LogWrite "Deploying $PrinterName" -type i
    Add-Printer -Name $PrinterName -PortName $PrinterPortName -DriverName $PrinterDriver
    
    #End of Script
    LogWrite "$eventlogSource script completed successfully- $TimeDate" -type end
}
catch [system.exception]
{
	$err = $_.Exception.Message
	LogWrite "Unable to deploy printer, `r`nError: $err" -type e
    #End of Script
    LogWrite "$eventlogSource script completed unsuccessfully- $TimeDate" -type end
} 